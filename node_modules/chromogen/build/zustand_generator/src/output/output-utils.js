"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateActLine = exports.testStateChangesExpect = exports.testStateChangesAct = exports.testInitialState = exports.importZustandStore = void 0;
const utils_1 = require("../utils/utils");
function importZustandStore() {
    return `import useStore from '<ADD STORE FILEPATH>';`;
}
exports.importZustandStore = importZustandStore;
function testInitialState(initialRender) {
    return Object.entries(initialRender).reduce((acc, [k, v]) => {
        return (acc
            + `\tit('${k} should initialize correctly', () => {\n\t\texpect(result.current.${k}).toStrictEqual(${JSON.stringify(v)});\n\t});\n\n`);
    }, '');
}
exports.testInitialState = testInitialState;
const dummyTransaction = { action: utils_1.dummyParam, changedValues: {} };
function testStateChangesAct(transactions) {
    let groupedTransactions = [...transactions, dummyTransaction].reduce((acc, cur) => {
        if (Object.keys(cur.changedValues).some((v) => acc.changedValues[v])
            || cur.action === utils_1.dummyParam) {
            acc.groups.push(acc.currentGroup);
            acc.currentGroup = [cur];
            acc.changedValues = Object.keys(cur.changedValues).reduce((acc, k) => {
                acc[k] = true;
                return acc;
            }, {});
        }
        else {
            acc.currentGroup.push(cur);
            Object.keys(cur.changedValues).forEach((k) => (acc.changedValues[k] = true));
        }
        return acc;
    }, { groups: [], currentGroup: [], changedValues: {} }).groups;
    return groupedTransactions.reduce((acc, group) => {
        const { str, actBlock } = generateItBlock(group);
        acc.str += str;
        acc.actStatements = actBlock;
        return acc;
    }, { str: '', actStatements: '' }).str;
}
exports.testStateChangesAct = testStateChangesAct;
function testStateChangesExpect([propertyName, newValue]) {
    return `\nexpect(result.current.${propertyName}).toStrictEqual(${JSON.stringify(newValue)});`;
}
exports.testStateChangesExpect = testStateChangesExpect;
function generateActLine(t) {
    const { action } = t;
    const args = t.arguments;
    return `\tresult.current.${action}(${args === null || args === void 0 ? void 0 : args.map((arg) => JSON.stringify(arg)).join(', ')});\n`;
}
exports.generateActLine = generateActLine;
function generateItBlock(transactions) {
    const valuesChanged = [];
    let expectBlock = '';
    transactions.forEach((t) => Object.entries(t.changedValues).forEach(([changedValue, newValue]) => {
        valuesChanged.push(changedValue);
        expectBlock += testStateChangesExpect([changedValue, newValue]);
    }));
    let newActBlock = transactions.map(generateActLine).join('');
    return {
        str: `\n\tit('${valuesChanged.join(' & ')} should update correctly', () => {
      const { result } = renderHook(useStore);
  
      act(() => {\n${newActBlock}\n});
  
      ${expectBlock}  
    });`,
        actBlock: newActBlock,
    };
}
