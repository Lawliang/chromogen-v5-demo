"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapSetter = exports.wrapGetter = exports.debouncedAddToTransactions = void 0;
const utils_1 = require("../utils/utils");
const ledger_1 = require("../utils/ledger");
const store_1 = require("../utils/store");
const { transactions, initialRender, selectors, setTransactions } = ledger_1.ledger;
const DEBOUNCE_MS = 250;
const debouncedAddToTransactions = (0, utils_1.debounce)((key, value, params) => params !== undefined
    ? transactions[transactions.length - 1].familyUpdates.push({ key, value, params })
    : transactions[transactions.length - 1].updates.push({ key, value }), DEBOUNCE_MS);
exports.debouncedAddToTransactions = debouncedAddToTransactions;
const wrapGetter = (key, get) => {
    let returnedPromise = false;
    return (utils) => {
        const value = get(utils);
        if (utils.get(store_1.recordingState)) {
            if (transactions.length === 0) {
                if (typeof value === 'object' && value !== null && value.constructor.name === 'Promise') {
                    ledger_1.ledger.selectors = selectors.filter((current) => current !== key);
                    returnedPromise = true;
                }
                else {
                    initialRender.push({ key, value });
                }
            }
            else if (!returnedPromise) {
                debouncedAddToTransactions(key, value);
            }
        }
        return value;
    };
};
exports.wrapGetter = wrapGetter;
const wrapSetter = (key, set) => (utils, newValue) => {
    if (utils.get(store_1.recordingState) && setTransactions.length > 0) {
        setTimeout(() => {
            setTransactions[setTransactions.length - 1].setter = { key, newValue };
        }, 0);
    }
    return set(utils, newValue);
};
exports.wrapSetter = wrapSetter;
